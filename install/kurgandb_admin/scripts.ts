import { getAPIMethod } from "@artempoletsky/easyrpc/client";
import { queryUniversal as query } from "@artempoletsky/kurgandb";
import { FieldType } from "@artempoletsky/kurgandb/globals";
import { TableScheme } from "@artempoletsky/kurgandb/table";
import fs from "fs";

function typeToTsType(type: FieldType): string {
  switch (type) {
    case "date": return "Date";
    case "json": return "any";
    default: return type;
  }
}
function tableNameToTypeName(tableName: string): string {
  if (tableName.endsWith("s")) {
    tableName = tableName.slice(0, tableName.length - 1);
  }
  const words = tableName.split("_").map(w => {
    if (!w) return "";
    const first = w[0].toUpperCase();
    return first + w.substring(1);
  });
  return words.join("");
}

export const exampleGroup = {
  async dangerous_GenerateDBfile() {
    let scheme: Record<string, TableScheme> = await query(({ }, { }, { db }) => {
      const res: Record<string, TableScheme> = {};
      const tableNames = Object.keys(db.getTables());
      for (const key of tableNames) {
        res[key] = db.getScheme(key) as any;
      }
      return res;
    }, {});

    let imports = `import { Predicate, queryUniversal } from "@artempoletsky/kurgandb";
import type { PlainObject } from "@artempoletsky/kurgandb/globals";
import type { Table } from "@artempoletsky/kurgandb/table";\r\n\r\n`;


    let tables = `export type Tables = {\r\n`;
    let queryDefinition = `export async function query<Payload extends PlainObject, ReturnType>(predicate: Predicate<Tables, Payload, ReturnType>, payload?: Payload) {
  return queryUniversal<Tables, Payload, ReturnType>(predicate, payload);
}\r\n\r\n`;
    let types = "";

    for (const tableName in scheme) {
      const tScheme = scheme[tableName];

      let primaryKey = "";
      let keyType = "";
      const typeName = tableNameToTypeName(tableName);
      types += `export type ${typeName} = {\r\n`;
      for (const fieldName in tScheme.fields) {
        const tags = new Set(tScheme.tags[fieldName] || []);
        const type = tScheme.fields[fieldName];
        const tsType = typeToTsType(type);
        types += `  ${fieldName}: ${tsType}\r\n`;
        if (tags.has("primary")) {
          primaryKey = fieldName;
          keyType = type;
        }
      }

      types += `}\r\n\r\n\r\n`;

      tables += `  ${tableName}: Table<${keyType}, ${typeName}>\r\n`;
    }
    tables += `}\r\n\r\n\r\n`;


    fs.writeFileSync(process.cwd() + "/db.ts", imports + tables + queryDefinition + types);

    return "success";
  },
  async exampleScript2() { return "2"; },
  deeperGroup: {
    async script() {
      // another comment
    }
  }
}

export async function exampleScript(argument1: string, argument2: string) {
  // You can add a descrition with the comment

  return `Hello world! ${argument1} ${argument2} `;
}


export const NextRoutes = {
  async createNewPage(path: string, mainComponentName: string) {
    if (!path) {
      return "Specify a path for the Next router!"
    }
    if (!mainComponentName) {
      mainComponentName = "UnnamedPage";
    }

    const dirPath = process.cwd() + "/app/" + path;
    if (fs.existsSync(dirPath)) return "Already exists!";

    fs.mkdirSync(process.cwd() + "/app/" + path, { recursive: true });
    const fileContents = `import { query } from "@/db";
import ${mainComponentName} from "./${mainComponentName}";
import { Metadata, ResolvingMetadata } from 'next';

// export const metadata: Metadata = {
//   title: "This page was autogenerated",
// };

export async function generateMetadata(props: Props, parent: ResolvingMetadata): Promise<Metadata> {
  const dbVersion = await query((tables, payload, { db }) => {
    return db.version
  });
  return {
    title: \`KurganDB v\${dbVersion}\`,
  }
}

type Props = {}
export default async function (props: Props) {
  const dbVersion = await query((tables, payload, { db }) => {
    return db.version
  });

  return (
    <div className="h-screen text-center items-center pt-[40vh]">
      <div className="">{\`KurganDB v\${dbVersion}\`}</div>
      <${mainComponentName}></${mainComponentName}>
    </div>
  );
}
`;
    fs.writeFileSync(dirPath + "/page.tsx", fileContents);

    const componentContents = `
"use client";

import { ValidationErrorResponse, getAPIMethod } from "@artempoletsky/easyrpc/client";
import { FSayHello } from "./api/route";
import { useState } from "react";

const sayHello = getAPIMethod<FSayHello>("${path}/api", "sayHello");

export default function TestComponent() {
  const [greeting, setGreeting] = useState("");
  const [name, setName] = useState("");
  const [errorMessage, setErrorMessage] = useState<ValidationErrorResponse | undefined>();

  function onClick() {
    sayHello({
      name
    })
      .then(setGreeting)
      .catch(setErrorMessage);
  }
  return (
    <div className="">
      <div className="inline-flex gap-3">
        <input
          placeholder="Type your name"
          className="rounded bg-gray-200 border border-blue-500 px-3 py-1 text-black h-[36px]"
          value={name}
          onChange={e => setName(e.target.value)}
          type="text"
        />
        <button className="rounded bg-blue-500 px-3 py-1 text-white h-[36px]" onClick={onClick}>{greeting ? greeting : "Say hello!"}</button>
      </div>

      {errorMessage &&
        <div className="text-red-600">{errorMessage.message}</div>
      }
    </div>
  );
}`;

    fs.writeFileSync(dirPath + `/${mainComponentName}.tsx`, componentContents);


  },

  async createNewAPI(path: string) {
    const dirPath = process.cwd() + "/app/" + path;
    if (fs.existsSync(dirPath)) return "Already exists!";

    fs.mkdirSync(process.cwd() + "/app/" + path, { recursive: true });
    const fileContents = `import { NextPOST } from "@artempoletsky/easyrpc";
import { NextResponse } from "next/server";
import * as schemas from "./schemas";
import type { ASayHello } from "./schemas";
// import { query } from "@/db";



async function sayHello({ name }: ASayHello) {
  // const user = await query((tables, { name }) => {
  //   return tables.users.at(name);
  // }, { name });

  return \`Hello, \${name}!\`;
}
export type FSayHello = typeof sayHello;



export const POST = NextPOST(NextResponse, schemas, {
  sayHello
});`;
    fs.writeFileSync(dirPath + "/route.ts", fileContents);

    const schemasContents = `import z from "zod";


export const sayHello = z.object({
  name: z.string()
});
export type ASayHello = z.infer<typeof sayHello>;

`;
    fs.writeFileSync(dirPath + "/schemas.ts", schemasContents);

    return "Success!";
  },
}